# WebSocket API Documentation

This document describes the WebSocket events used for real-time communication between the DayTradersPro server and client.

## Overview

The client connects to the server via Socket.IO and listens for various events to update the UI in real-time without polling. All events are emitted from the server to connected clients.

## Instance Management Events

### `instanceStateChanged`
Emitted when an instance's status or properties change (start, stop, status updates).

**Payload:**
```javascript
{
  instanceId: string,     // Unique instance identifier
  state: {
    status: string,       // 'RUNNING', 'STOPPED', 'STARTING', 'STOPPING', 'PAUSED', 'ERROR'
    startedAt?: Date,     // When instance was started (if running)
    stoppedAt?: Date,     // When instance was stopped (if stopped)
    lastUpdate?: Date,    // Last status update timestamp
    // ... other instance properties that changed
  }
}
```

**When to emit:**
- After successful start/stop operations
- When instance status transitions occur
- When instance properties are updated

### `instanceCreated`
Emitted when a new instance is created.

**Payload:**
```javascript
{
  id: string,
  name: string,
  symbol: string,
  algorithm: string,
  accountId: string,
  status: string,
  simulationMode: boolean,
  createdAt: Date,
  // ... full instance object
}
```

### `instanceDeleted`
Emitted when an instance is deleted.

**Payload:**
```javascript
{
  instanceId: string
}
```

### `instanceStates`
Emitted to provide initial state of all instances (typically on client connection).

**Payload:**
```javascript
[
  {
    id: string,
    name: string,
    status: string,
    // ... full instance objects
  }
]
```

## Trading Events

### `instanceSignal`
Emitted when a trading signal is generated by an instance.

**Payload:**
```javascript
{
  instanceId: string,
  signal: {
    type: string,         // 'ENTRY', 'EXIT'
    side: string,         // 'LONG', 'SHORT'
    reason: string,       // Algorithm-specific reason
    confidence: number,   // Signal confidence (0-1)
    timestamp: Date
  },
  pnL?: number,          // Current P&L if available
  timestamp: Date
}
```

### `instanceDataUpdate`
Emitted when market data updates affect an instance.

**Payload:**
```javascript
{
  instanceId: string,
  candle: {
    timestamp: Date,
    open: number,
    high: number,
    low: number,
    close: number,
    volume: number
  }
}
```

## Logging Events

### `instanceLog`
Emitted when important log events occur for an instance.

**Payload:**
```javascript
{
  instanceId: string,
  message: string,
  level: string,        // 'info', 'warn', 'error', 'debug'
  timestamp: Date,
  context?: object      // Additional context data
}
```

## Client-Side Event Handlers

The client automatically handles these events in `src/stores/instances.js`:

```javascript
// Instance state management
socketService.on('instanceStates', (states) => { /* ... */ })
socketService.on('instanceStateChanged', (data) => { /* ... */ })
socketService.on('instanceCreated', (instance) => { /* ... */ })
socketService.on('instanceDeleted', (data) => { /* ... */ })

// Trading events
socketService.on('instanceSignal', (signal) => { /* ... */ })
socketService.on('instanceDataUpdate', (data) => { /* ... */ })

// Logging
socketService.on('instanceLog', (logData) => { /* ... */ })
```

## Implementation Notes

### Server-Side Implementation
1. Import Socket.IO in your server
2. Emit events after successful operations
3. Ensure events are emitted to all connected clients or specific rooms

### Example Server Implementation
```javascript
// After starting an instance
io.emit('instanceStateChanged', {
  instanceId: instance.id,
  state: {
    status: 'RUNNING',
    startedAt: new Date()
  }
})

// After stopping an instance
io.emit('instanceStateChanged', {
  instanceId: instance.id,
  state: {
    status: 'STOPPED',
    stoppedAt: new Date()
  }
})
```

## Backtest Events

### backtestUpdate

Emitted during backtest execution to provide real-time progress updates.

**Event:** `backtestUpdate`

**Payload:**
```javascript
{
  backtestId: string,           // Unique backtest execution identifier
  status: string,               // 'STARTING', 'LOADING_DATA', 'FETCHING_DATA', 'DATA_LOADED', 'RUNNING', 'COMPLETED', 'FAILED'
  progress?: number,            // Progress percentage (0-100) when status is 'RUNNING'
  message: string,              // Human-readable status message
  error?: string,               // Error message if status is 'FAILED'
  results?: object             // Complete backtest results when status is 'COMPLETED'
}
```

**Example Usage:**
```javascript
// Listen for backtest updates
socket.on('backtestUpdate', (update) => {
  console.log(`Backtest ${update.backtestId}: ${update.message}`);

  if (update.progress) {
    updateProgressBar(update.progress);
  }

  if (update.status === 'COMPLETED') {
    displayResults(update.results);
  }

  if (update.status === 'FAILED') {
    showError(update.error);
  }
});
```

**Example Events:**
```javascript
// Data loading phase
{
  backtestId: "uuid-1234",
  status: "LOADING_DATA",
  message: "Loading historical data for NQ from Thu Aug 01 2025 to Fri Aug 02 2025..."
}

// Data fetching from external API
{
  backtestId: "uuid-1234",
  status: "FETCHING_DATA",
  message: "Fetching historical data from Project X for NQ..."
}

// Data loaded successfully
{
  backtestId: "uuid-1234",
  status: "DATA_LOADED",
  message: "Loaded 1260 candles from Project X"
}

// Execution progress
{
  backtestId: "uuid-1234",
  status: "RUNNING",
  progress: 45.2,
  message: "Processing... 45.2%"
}

// Completion with results
{
  backtestId: "uuid-1234",
  status: "COMPLETED",
  progress: 100,
  message: "Backtest completed successfully",
  results: {
    totalTrades: 28,
    winningTrades: 13,
    totalPnL: -111,
    // ... complete results object
  }
}

// Error case
{
  backtestId: "uuid-1234",
  status: "FAILED",
  message: "Backtest failed: Invalid algorithm configuration",
  error: "Invalid algorithm configuration"
}
```

### Benefits
- **Real-time updates**: UI updates immediately when server state changes
- **No polling**: Eliminates unnecessary HTTP requests and console noise
- **Efficient**: Only sends data when changes occur
- **Scalable**: WebSocket connections handle multiple concurrent updates

## Migration from Polling

The client has been updated to remove all polling mechanisms:
- ❌ Auto-refresh intervals removed
- ❌ Forced refresh calls removed
- ❌ Console logging noise eliminated
- ✅ WebSocket event handlers ready
- ✅ Real-time UI updates implemented

Once server-side WebSocket events are implemented, the system will provide true real-time updates without any polling overhead.
